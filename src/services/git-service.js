import { Octokit } from "@octokit/rest";

class GitService {
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });
    this.apiBaseUrl = process.env.API_BASE_URL || 'http://localhost:3000';
  }

  parseGitHubUrl(url) {
    // From: https://github.com/owner/repo/pull/123
    const match = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!match) throw new Error("Invalid GitHub URL");
    return { owner: match[1], repo: match[2] };
  }

  /**
   * Get unique directories from changed files
   */
  /**
   * Call external API to get file analysis and paths
   */
  async callAnalysisAPI(changedFiles) {
    try {
      console.log('Calling analysis API...');
      
      const response = await fetch(`${this.apiBaseUrl}/api/analyze-files`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          changedFiles: changedFiles
        })
      });

      if (!response.ok) {
        throw new Error(`Analysis API error: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      console.log('Analysis API response received:', {
        filesCount: result.filesToCreate?.length || 0,
        analysisId: result.analysisId,
        filePaths: result.filesToCreate?.map(f => f.path) || []
      });

      return result;
    } catch (error) {
      console.error('Error calling analysis API:', error.message);
      throw error;
    }
  }



  /**
   * Create new branch remotely via GitHub API
   */
  async createRemoteBranch(repoUrl, baseBranch, newBranchName) {
    const { owner, repo } = this.parseGitHubUrl(repoUrl);

    console.log(
      `Creating remote branch: ${newBranchName} based on ${baseBranch}`
    );

    try {
      // Get the SHA of the base branch
      const baseBranchRef = await this.octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${baseBranch}`,
      });

      const baseSha = baseBranchRef.data.object.sha;
      console.log(`Base branch ${baseBranch} SHA: ${baseSha}`);

      // Create new branch
      await this.octokit.git.createRef({
        owner,
        repo,
        ref: `refs/heads/${newBranchName}`,
        sha: baseSha,
      });

      console.log(`Successfully created remote branch: ${newBranchName}`);
      return { owner, repo, baseSha };
    } catch (error) {
      console.error("Error creating remote branch:", error.message);
      throw error;
    }
  }

  /**
   * Create files remotely via GitHub API using API response
   */
  async createFilesFromAPIResponse(
    owner,
    repo,
    branchName,
    apiResponse,
    prData
  ) {
    const createdFiles = [];

    console.log(`ðŸ“ Creating ${apiResponse.filesToCreate.length} files from API response...`);

    for (const fileData of apiResponse.filesToCreate) {
      try {
        // Create file using GitHub API
        await this.octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: fileData.path,
          message: `Add ${fileData.type} file for PR #${prData.number} analysis`,
          content: Buffer.from(fileData.content).toString("base64"),
          branch: branchName,
        });

        createdFiles.push(fileData.path);

        console.log(`Created file: ${fileData.path}`);
      } catch (error) {
        console.error(`Error creating file ${fileData.path}:`, error.message);
        throw error;
      }
    }

    console.log(`ðŸŽ‰ Successfully created ${createdFiles.length} files remotely`);
    return createdFiles;
  }

  /**
   * Create pull request (as draft initially)
   */
  async createPullRequest(
    owner,
    repo,
    newBranchName,
    baseBranch,
    prData,
    isDraft = true
  ) {
    const title = `Auto-generated Covlant-app analysis for PR #${prData.number}: ${prData.title}`;
    const body = `## Automated PR Analysis ${isDraft ? "(Draft)" : ""}

This PR was automatically generated in response to PR #${prData.number}.

### Original PR Details
- **Base Branch**: ${baseBranch}
- **Head Branch**: ${newBranchName}

---
*Auto-generated by fastify-github-webhook at ${new Date().toISOString()}*`;

    try {
      const response = await this.octokit.pulls.create({
        owner,
        repo,
        title,
        head: newBranchName,
        base: baseBranch, // This creates PR on top of the original PR's branch
        body,
        draft: isDraft, // Create as draft initially
      });

      const status = isDraft ? "draft PR" : "PR";
      console.log(
        `Created ${status} #${response.data.number}: ${response.data.html_url}`
      );
      return response.data;
    } catch (error) {
      console.error("Error creating PR:", error.message);
      throw error;
    }
  }

  /**
   * Main workflow: Process PR and create analysis PR remotely
   */
  async processPRAndCreateAnalysis(prData, fileChanges) {
    try {
      console.log("=== Starting Remote PR Analysis Workflow ===");

      // Generate unique branch name with clear auto-generated marker
      const timestamp = Date.now();
      const newBranchName = `auto-analysis-pr-${prData.number}-${timestamp}`;

      // Safety check: Ensure we don't process our own PRs
      if (prData.headBranch.startsWith("auto-analysis-pr-")) {
        throw new Error(
          "Attempted to process auto-generated PR - this should have been caught earlier!"
        );
      }

      // Create remote branch (based on the PR's head branch)
      const { owner, repo } = await this.createRemoteBranch(
        prData.url,
        prData.headBranch, // Use the PR's head branch as base
        newBranchName
      );

      // Call analysis API to get file paths and content
      const apiResponse = await this.callAnalysisAPI(fileChanges);

      // Create files remotely using API response
      const createdFiles = await this.createFilesFromAPIResponse(
        owner,
        repo,
        newBranchName,
        apiResponse,
        prData
      );

      // Create draft PR (on top of the original PR)
      const newPR = await this.createPullRequest(
        owner,
        repo,
        newBranchName,
        prData.headBranch, // Base it on the original PR's head branch
        prData,
        true // Create as draft
      );

      console.log("=== Remote PR Analysis Workflow Completed ===");
      return {
        success: true,
        newPR: {
          number: newPR.number,
          url: newPR.html_url,
          branch: newBranchName,
          isDraft: newPR.draft,
        },
        createdFiles,
        analysisId: apiResponse.analysisId,
        apiResponse: {
          timestamp: apiResponse.timestamp,
          filesCount: apiResponse.filesToCreate.length,
          filePaths: apiResponse.filesToCreate.map(f => f.path)
        }
      };
    } catch (error) {
      console.error("Error in remote PR analysis workflow:", error.message);
      throw error;
    }
  }
}

export default GitService;
